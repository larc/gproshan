#include "mesh/che_obj.h"

#include <cstring>
#include <cstdio>
#include <cassert>
#include <fstream>

using namespace std;


// geometry processing and shape analysis framework
namespace gproshan {


che_obj::che_obj(const string & file)
{
	init(file);
}

che_obj::che_obj(const che_obj & mesh): che(mesh)
{
}

void che_obj::read_file(const string & file)
{
	FILE * fp = fopen(file.c_str(), "r");
	assert(fp);

	real_t x, y, z;
	int v[16], vt[16], vn[16], f;

	vector<vertex> vertices;
	vector<index_t> vs;

	char line[256], key[4];
	char * line_ptr;
	int offset;

	while(fgets(line, sizeof(line), fp))
	{
		key[0] = 0;
		line_ptr = line;
		
		sscanf(line_ptr, "%s%n", key, &offset);
		line_ptr += offset;

		if(key[0] == 'v' && !key[1])	// v x y z
		{
			sscanf(line_ptr, "%f %f %f%n", &x, &y, &z, &offset);
			vertices.push_back({x, y, z});
		}

		if(key[0] == 'f')				// f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3 ...
		{
			f = 0;
			while(sscanf(line_ptr, "%d/%d/%d%n", v + f, vt + f, vn + f, &offset) > 0)
			{
				line_ptr += offset;
				++f;
			}

			if(f == che::mtrig)
			{
				if(v[0] < 0)
				{
					vs.push_back(vertices.size() + v[0]);
					vs.push_back(vertices.size() + v[1]);
					vs.push_back(vertices.size() + v[2]);
				}
				else
				{
					vs.push_back(v[0] - 1);
					vs.push_back(v[1] - 1);
					vs.push_back(v[2] - 1);
				}
			}
			else if(f == che::mquad)
			{
				if(v[0] < 0)
				{
					vs.push_back(vertices.size() + v[0]);
					vs.push_back(vertices.size() + v[1]);
					vs.push_back(vertices.size() + v[3]);

					vs.push_back(vertices.size() + v[1]);
					vs.push_back(vertices.size() + v[2]);
					vs.push_back(vertices.size() + v[3]);
				}
				else
				{
					vs.push_back(v[0] - 1);
					vs.push_back(v[1] - 1);
					vs.push_back(v[3] - 1);

					vs.push_back(v[1] - 1);
					vs.push_back(v[2] - 1);
					vs.push_back(v[3] - 1);
				}
			}
		}
	}

	fclose(fp);

	init(vertices.data(), vertices.size(), vs.data(), vs.size() / che::mtrig);
}

void che_obj::write_file(const che * mesh, const string & file)
{
	ofstream os(file + ".obj");

	os << "####\n#\n";
	os << "# OBJ generated by gproshan 2019" << endl;
	os << "# vertices: " << mesh->n_vertices << endl;
	os << "# faces: " << mesh->n_faces << endl;
	os << "#\n####\n";

	for(size_t v = 0; v < mesh->n_vertices; ++v)
		os << "v " << mesh->gt(v) << endl;

	for(index_t he = 0; he < mesh->n_half_edges; )
	{
		os << "f";
		for(index_t i = 0; i < che::mtrig; ++i)
			os << " " << mesh->vt(he++) + 1;
		os << endl;
	}

	os.close();
}


} // namespace gproshan

