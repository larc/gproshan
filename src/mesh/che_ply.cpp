#include "mesh/che_ply.h"

#include <fstream>
#include <sstream>
#include <vector>
#include <cstring>
#include <cassert>
#include <map>


using namespace std;


// geometry processing and shape analysis framework
namespace gproshan {


che_ply::che_ply(const string & file)
{
	init(file);
}

void che_ply::read_file(const string & file)
{
	map<string, size_t> bytes =	{
									{"char", 1},
									{"uchar", 1},
									{"short", 2},
									{"ushort", 2},
									{"int", 4},
									{"uint", 4},
									{"float", 4},
									{"float32", 4},
									{"float64", 8},
									{"double", 8}
								};

	size_t nv = 0, nf = 0, b;
	index_t P[32];

	string str, format, element;

	ifstream is(file);
	assert(is.good());

	size_t xyz = 0, vbytes = 0;
	size_t fn = 0, fbytes = 0;

	while(getline(is, str) && str != "end_header")
	{
		stringstream ss(str);

		str = "";
		ss >> str;

		if(str == "element")
		{
			ss >> element;
			if(element == "vertex") ss >> nv;
			if(element == "face") ss >> nf;
		}

		if(str == "property" && element == "vertex")
		{
			ss >> str;
			vbytes += b = bytes[str];

			ss >> str;
			if(str == "x" || str == "y" || str == "z")
				xyz = b;
		}

		if(str == "property" && element == "face")
		{
			ss >> str;
			if(str == "list")
			{
				ss >> str; fn = bytes[str];
				ss >> str; fbytes = bytes[str];
			}
		}

		if(str == "format") ss >> format;
	}

	alloc(nv, nf);

	vector<index_t> faces;
	faces.reserve(che::mtrig * n_faces);

	if(format == "ascii")
	{
		for(index_t v = 0; v < n_vertices; ++v)
		{
			getline(is, str);
			stringstream ss(str);

			ss >> GT[v];
		}

		while(nf--)
		{
			getline(is, str);
			stringstream ss(str);

			ss >> nv;
			for(index_t i = 0; i < nv; ++i)
				ss >> P[i];

			for(const index_t & v: trig_convex_polygon(P, nv))
				faces.push_back(v);
		}
	}
	else // binary_little_endian
	{
		bool big_endian = format == "binary_big_endian";
		auto big_to_little = [](char * buffer, const index_t & n)
		{
			for(index_t i = 0, j = n - 1; i < j; ++i, --j)
				swap(buffer[i], buffer[j]);
		};

		char * vbuffer = new char[vbytes];
		for(index_t v = 0; v < n_vertices; ++v)
		{
			is.read(vbuffer, vbytes);
			if(big_endian) big_to_little(vbuffer, vbytes);

			if(xyz == sizeof(real_t))
				memcpy(&GT[v], vbuffer, 3 * sizeof(real_t));
			else
			{
				if(xyz == 4)
				{
					float * X = (float *) vbuffer;
					for(index_t i = 0; i < 3; ++i)
						GT[v][i] = X[i];
				}
				else
				{
					double * X = (double *) vbuffer;
					for(index_t i = 0; i < 3; ++i)
						GT[v][i] = (real_t) X[i];
				}
			}
		}

		while(nf--)
		{
			is.read(vbuffer, fn);
			if(big_endian) big_to_little(vbuffer, fn);

			if(fn == 1) nv = *((char *) vbuffer);
			if(fn == 2) nv = *((short *) vbuffer);
			if(fn == 4) nv = *((int *) vbuffer);

			for(index_t i = 0; i < nv; ++i)
			{
				is.read(vbuffer, fbytes);
				if(big_endian) big_to_little(vbuffer, fbytes);

				if(fbytes == 1) P[i] = *((char *) vbuffer);
				if(fbytes == 2) P[i] = *((short *) vbuffer);
				if(fbytes == 4) P[i] = *((int *) vbuffer);
			}

			for(const index_t & v: trig_convex_polygon(P, nv))
				faces.push_back(v);
		}

		delete [] vbuffer;
	}

	is.close();


	if(faces.size() != che::mtrig * n_faces)
	{
		vertex * tGT = GT; GT = nullptr;

		free();
		alloc(nv, faces.size() / che::mtrig);

		GT = tGT;
	}

	memcpy(VT, faces.data(), faces.size() * sizeof(index_t));
}

void che_ply::write_file(const che * mesh, const string & file)
{
	ofstream os(file + ".ply");

	os << "ply" << endl;
	os << "format ascii 1.0" << endl;
	os << "comment generated by gproshan 2020" << endl;
	os << "element vertex " << mesh->n_vertices << endl;
	os << "property float x" << endl;
	os << "property float y" << endl;
	os << "property float z" << endl;
	os << "element face " << mesh->n_faces << endl;
	os << "property list uchar int vertex_index" << endl;
	os << "end_header" << endl;

	for(size_t v = 0; v < mesh->n_vertices; ++v)
		os << mesh->gt(v) << endl;

	for(index_t he = 0; he < mesh->n_half_edges; )
	{
		os << che::mtrig;
		for(index_t i = 0; i < che::mtrig; ++i)
			os << " " << mesh->vt(he++);
		os << endl;
	}

	os.close();
}


} // namespace gproshan

