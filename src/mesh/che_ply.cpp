#include "mesh/che_ply.h"

#include <cstring>
#include <cstdio>
#include <cassert>
#include <fstream>
#include <map>


using namespace std;


// geometry processing and shape analysis framework
namespace gproshan {


che_ply::che_ply(const string & file)
{
	init(file);
}

void che_ply::read_file(const string & file)
{
	map<string, size_t> bytes = {
									{"char", 1},
									{"uchar", 1},
									{"short", 2},
									{"ushort", 2},
									{"int", 4},
									{"uint", 4},
									{"float", 4},
									{"float32", 4},
									{"float64", 8},
									{"double", 8}
								};

	FILE * fp = fopen(file.c_str(), "rb");
	assert(fp);

	size_t nv = 0, nf = 0, b;
	size_t xyz = 0, vbytes = 0;
	size_t fn = 0, fbytes = 0;
	index_t P[32];

	char line[256], str[32], format[32], element[32];

	while(fgets(line, sizeof(line), fp) && line[1] != 'n')	// end_header
	{
		sscanf(line, "%s", str);

		if(str[0] == 'f')	// format
			sscanf(line, "%*s %s", format);

		if(str[0] == 'e')	// element
		{
			sscanf(line, "%*s %s", element);
			if(element[0] == 'v')	// vertex
				sscanf(line, "%*s %*s %lu", &nv);
			if(element[0] == 'f')	// face
				sscanf(line, "%*s %*s %lu", &nf);
		}

		if(str[0] == 'p' && element[0] == 'v')	// property vertex
		{
			sscanf(line, "%*s %s", str);
			vbytes += b = bytes[str];

			sscanf(line, "%*s %*s %s", str);
			if(str[0] == 'x' || str[0] == 'y' || str[0] == 'z')
				xyz = b;
		}

		if(str[0] == 'p' && element[0] == 'f')	// property face
		{
			sscanf(line, "%*s %s", str);
			if(str[0] == 'l')	// list
			{
				sscanf(line, "%*s %*s %s", str);
				fn = bytes[str];
				sscanf(line, "%*s %*s %*s %s", str);
				fbytes = bytes[str];
			}
		}
	}

	alloc(nv, nf);

	vector<index_t> faces;
	faces.reserve(che::mtrig * n_faces);

	if(format[0] == 'a')	// ascii
	{
		float x, y, z;
		for(index_t v = 0; v < n_vertices; ++v)
		{
			fscanf(fp, "%f %f %f", &x, &y, &z);
			GT[v] = {x, y, z};
		}

		while(nf--)
		{
			fscanf(fp, "%lu", &nv);
			for(index_t i = 0; i < nv; ++i)
				fscanf(fp, "%u", P + i);

			for(const index_t & v: trig_convex_polygon(P, nv))
				faces.push_back(v);
		}
	}
	else // binary_little_endian or binary_big_endian
	{
		bool big_endian = format[7] == 'b';
		auto big_to_little = [](char * buffer, const index_t & n)
		{
			for(index_t i = 0, j = n - 1; i < j; ++i, --j)
				swap(buffer[i], buffer[j]);
		};

		char * buffer = new char[vbytes];

		for(index_t v = 0; v < n_vertices; ++v)
		{
			fread(buffer, 1, vbytes, fp);
			if(big_endian) big_to_little(buffer, vbytes);

			if(xyz == sizeof(real_t))
				memcpy(&GT[v], buffer, 3 * sizeof(real_t));
			else
			{
				if(xyz == 4)
				{
					float * X = (float *) buffer;
					for(index_t i = 0; i < 3; ++i)
						GT[v][i] = X[i];
				}
				else
				{
					double * X = (double *) buffer;
					for(index_t i = 0; i < 3; ++i)
						GT[v][i] = (real_t) X[i];
				}
			}
		}

		while(nf--)
		{
			fread(buffer, 1, fn, fp);
			if(big_endian) big_to_little(buffer, fn);

			if(fn == 1) nv = *((char *) buffer);
			if(fn == 2) nv = *((short *) buffer);
			if(fn == 4) nv = *((int *) buffer);

			for(index_t i = 0; i < nv; ++i)
			{
				fread(buffer, 1, fbytes, fp);
				if(big_endian) big_to_little(buffer, fbytes);

				if(fbytes == 1) P[i] = *((char *) buffer);
				if(fbytes == 2) P[i] = *((short *) buffer);
				if(fbytes == 4) P[i] = *((int *) buffer);
			}

			for(const index_t & v: trig_convex_polygon(P, nv))
				faces.push_back(v);
		}

		delete [] buffer;
	}

	fclose(fp);


	if(faces.size() != che::mtrig * n_faces)
	{
		vertex * tGT = GT; GT = nullptr;

		free();
		alloc(nv, faces.size() / che::mtrig);

		GT = tGT;
	}

	memcpy(VT, faces.data(), faces.size() * sizeof(index_t));
}

void che_ply::write_file(const che * mesh, const string & file)
{
	ofstream os(file + ".ply");

	os << "ply" << endl;
	os << "format ascii 1.0" << endl;
	os << "comment generated by gproshan 2020" << endl;
	os << "element vertex " << mesh->n_vertices << endl;
	os << "property float x" << endl;
	os << "property float y" << endl;
	os << "property float z" << endl;
	os << "element face " << mesh->n_faces << endl;
	os << "property list uchar int vertex_index" << endl;
	os << "end_header" << endl;

	for(size_t v = 0; v < mesh->n_vertices; ++v)
		os << mesh->gt(v) << endl;

	for(index_t he = 0; he < mesh->n_half_edges; )
	{
		os << che::mtrig;
		for(index_t i = 0; i < che::mtrig; ++i)
			os << " " << mesh->vt(he++);
		os << endl;
	}

	os.close();
}


} // namespace gproshan

