#include "mesh/che_ply.h"

#include <cstring>
#include <cstdio>
#include <cassert>
#include <map>


using namespace std;


// geometry processing and shape analysis framework
namespace gproshan {


che_ply::che_ply(const string & file)
{
	init(file);
}

void che_ply::read_file(const string & file)
{
	map<string, size_t> bytes = {
									{"char", 1},
									{"uchar", 1},
									{"short", 2},
									{"ushort", 2},
									{"int", 4},
									{"uint", 4},
									{"float", 4},
									{"float32", 4},
									{"float64", 8},
									{"double", 8}
								};

	FILE * fp = fopen(file.c_str(), "rb");
	assert(fp);

	size_t nv = 0, nf = 0, b;
	size_t xyz = 0, vbytes = 0;
	size_t fn = 0, fbytes = 0;
	index_t P[32];

	char line[256], str[32], format[32], element[32];

	while(fgets(line, sizeof(line), fp) && line[1] != 'n')	// end_header
	{
		sscanf(line, "%s", str);

		if(str[0] == 'f')	// format
			sscanf(line, "%*s %s", format);

		if(str[0] == 'e')	// element
		{
			sscanf(line, "%*s %s", element);
			if(element[0] == 'v')	// vertex
				sscanf(line, "%*s %*s %lu", &nv);
			if(element[0] == 'f')	// face
				sscanf(line, "%*s %*s %lu", &nf);
		}

		if(str[0] == 'p' && element[0] == 'v')	// property vertex
		{
			sscanf(line, "%*s %s", str);
			vbytes += b = bytes[str];

			sscanf(line, "%*s %*s %s", str);
			if(str[0] == 'x' || str[0] == 'y' || str[0] == 'z')
				xyz = b;
		}

		if(str[0] == 'p' && element[0] == 'f')	// property face
		{
			sscanf(line, "%*s %s", str);
			if(str[0] == 'l')	// list
			{
				sscanf(line, "%*s %*s %s", str);
				fn = bytes[str];
				sscanf(line, "%*s %*s %*s %s", str);
				fbytes = bytes[str];
			}
		}
	}

	alloc(nv, nf);

	vector<index_t> faces;
	faces.reserve(che::mtrig * n_faces);

	if(format[0] == 'a')	// ascii
	{
		float x, y, z;
		for(index_t v = 0; v < n_vertices; ++v)
		{
			fscanf(fp, "%f %f %f", &x, &y, &z);
			GT[v] = {x, y, z};
		}

		while(nf--)
		{
			fscanf(fp, "%lu", &nv);
			for(index_t i = 0; i < nv; ++i)
				fscanf(fp, "%u", P + i);

			for(const index_t & v: trig_convex_polygon(P, nv))
				faces.push_back(v);
		}
	}
	else // binary_little_endian or binary_big_endian
	{
		bool big_endian = format[7] == 'b';
		auto big_to_little = [](char * buffer, const index_t & n)
		{
			for(index_t i = 0, j = n - 1; i < j; ++i, --j)
				swap(buffer[i], buffer[j]);
		};

		char * buffer = new char[vbytes];

		for(index_t v = 0; v < n_vertices; ++v)
		{
			fread(buffer, 1, vbytes, fp);
			if(big_endian) big_to_little(buffer, vbytes);

			if(xyz == sizeof(real_t))
				memcpy(&GT[v], buffer, 3 * sizeof(real_t));
			else
			{
				if(xyz == 4)
				{
					float * X = (float *) buffer;
					for(index_t i = 0; i < 3; ++i)
						GT[v][i] = X[i];
				}
				else
				{
					double * X = (double *) buffer;
					for(index_t i = 0; i < 3; ++i)
						GT[v][i] = (real_t) X[i];
				}
			}
		}

		while(nf--)
		{
			fread(buffer, 1, fn, fp);
			if(big_endian) big_to_little(buffer, fn);

			if(fn == 1) nv = *((char *) buffer);
			if(fn == 2) nv = *((short *) buffer);
			if(fn == 4) nv = *((int *) buffer);

			for(index_t i = 0; i < nv; ++i)
			{
				fread(buffer, 1, fbytes, fp);
				if(big_endian) big_to_little(buffer, fbytes);

				if(fbytes == 1) P[i] = *((char *) buffer);
				if(fbytes == 2) P[i] = *((short *) buffer);
				if(fbytes == 4) P[i] = *((int *) buffer);
			}

			for(const index_t & v: trig_convex_polygon(P, nv))
				faces.push_back(v);
		}

		delete [] buffer;
	}

	fclose(fp);


	if(faces.size() != che::mtrig * n_faces)
	{
		vertex * tGT = GT; GT = nullptr;

		free();
		alloc(nv, faces.size() / che::mtrig);

		GT = tGT;
	}

	memcpy(VT, faces.data(), faces.size() * sizeof(index_t));
}

void che_ply::write_file(const che * mesh, const string & file)
{
	FILE * fp = fopen((file + ".ply").c_str(), "wb");
	assert(fp);

	const char * type = sizeof(real_t) == 4 ? "float" : "double";

	fprintf(fp, "ply\n");
	fprintf(fp, "format binary_little_endian 1.0\n");
	fprintf(fp, "comment PLY generated by gproshan\n");
	fprintf(fp, "element vertex %lu\n", mesh->n_vertices);
	fprintf(fp, "property %s x\n", type);
	fprintf(fp, "property %s y\n", type);
	fprintf(fp, "property %s z\n", type);
	fprintf(fp, "element face %lu\n", mesh->n_faces);
	fprintf(fp, "property list uchar uint vertex_indices\n");
	fprintf(fp, "end_header\n");

	fwrite(&mesh->gt(0), sizeof(vertex), mesh->n_vertices, fp);

	unsigned char mtrig = che::mtrig;
	for(index_t he = 0; he < mesh->n_half_edges; he += che::mtrig)
	{
		fwrite(&mtrig, 1, 1, fp);
		fwrite(&mesh->vt(he), sizeof(index_t), che::mtrig, fp);
	}

	fclose(fp);
}


} // namespace gproshan

