#include <gproshan/mesh/che_obj.h>

#include <cstring>
#include <cstdio>
#include <cassert>


// geometry processing and shape analysis framework
namespace gproshan {


che_obj::che_obj(const std::string & file)
{
	init(file);
}

void che_obj::read_file(const std::string & file)
{
	parser p(file);
	alloc(p.vertices.size(), p.faces.size() / che::mtrig);
	memcpy(GT, p.vertices.data(), p.vertices.size() * sizeof(vertex));
	memcpy(VC, p.vcolors.data(), p.vcolors.size() * sizeof(rgb_t));
	memcpy(VT, p.faces.data(), p.faces.size() * sizeof(index_t));
}

void che_obj::write_file(const che * mesh, const std::string & file, const bool & color, const bool & pointcloud)
{
	FILE * fp = fopen((file + ".obj").c_str(), "w");
	assert(fp);

	fprintf(fp, "# OBJ generated by gproshan\n");
	fprintf(fp, "# vertices %lu\n", mesh->n_vertices);
	fprintf(fp, "# faces %lu\n", mesh->n_faces);

	for(index_t i = 0; i < mesh->n_vertices; ++i)
	{
		const vertex & v = mesh->point(i);
		fprintf(fp, "v %f %f %f", (float) v.x(), (float) v.y(), (float) v.z());
		if(color)
		{
			const vertex & c = mesh->color(i);
			fprintf(fp, " %f %f %f", (float) c.x(), (float) c.y(), (float) c.z());
		}
		fprintf(fp, "\n");
	}

	if(!pointcloud)
	{
		for(index_t he = 0; he < mesh->n_half_edges; )
		{
			fprintf(fp, "f");
			for(index_t i = 0; i < che::mtrig; ++i)
				fprintf(fp, " %u", mesh->halfedge(he++) + 1);
			fprintf(fp, "\n");
		}
	}

	fclose(fp);
}

che_obj::parser::parser(const std::string & file)
{
	FILE * fp = fopen(file.c_str(), "r");
	assert(fp);

	std::vector<index_t> P;
	uvec3 vtn;
	index_t n;
	float x, y, z, r, g, b;
	char line[256], str[64];

	while(fgets(line, sizeof(line), fp))
	{
		switch(line[0])
		{
			case 'f':
			{
				P.clear(); vtn = {}; n = 0;
				for(index_t i = 2; line[i]; ++i)
					switch(line[i])
					{
						case '/': ++n; break;
						case '\n':
						case ' ':
							P.push_back(vtn[0]);
							vtn = {}; n = 0;
							break;
						default:
							vtn[n] = 10 * vtn[n] + line[i] - '0';
							break;
					}

				for(index_t & i: P)
					i += i > vertices.size() ?  vertices.size() : -1;

				for(const index_t & v: trig_convex_polygon(P.data(), P.size()))
					faces.push_back(v);
				break;
			}
			case 'v':
			{
				n = sscanf(line, "%*s %f %f %f %f %f %f", &x, &y, &z, &r, &g, &b);
				switch(line[1])
				{
					case ' ':
						vertices.push_back({x, y, z});
						n == 6 ? vcolors.emplace_back(r, g, b) : vcolors.emplace_back();
						break;
					case 'n':
						vnormals.push_back({x, y, z});
						break;
					case 't':
						vtexcoords.push_back({x, y, z});
						break;
				}
				break;
			}
			case 'u':	// usemtl
			{
				sscanf(line, "%*s %s", str);
				objects.emplace_back(str, faces.size());
				break;
			}
			case 'm':	// mtllib
			{
				sscanf(line, "%*s %s", str);
				mtllibs.insert(str);
				break;
			}
		}
	}

	fclose(fp);

	gproshan_error_var(vertices.size());
	gproshan_error_var(vnormals.size());
	gproshan_error_var(vtexcoords.size());
	gproshan_error_var(vcolors.size());
	gproshan_error_var(faces.size());
	gproshan_error_var(objects.size());
	for(auto & o: objects)
		gproshan_log_var(o.first);
	for(auto & mtllib: mtllibs)
		gproshan_log_var(mtllib);
}


} // namespace gproshan

