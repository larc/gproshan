#include <gproshan/mesh/che_obj.h>

#include <cstring>
#include <cstdio>
#include <cassert>


// geometry processing and shape analysis framework
namespace gproshan {


che_obj::che_obj(const std::string & file)
{
	init(file);
}

void che_obj::read_file(const std::string & file)
{
	parser p(file);
	alloc(p.vertices.size(), p.trigs.size() / che::mtrig);
	memcpy(GT, p.vertices.data(), p.vertices.size() * sizeof(vertex));
	memcpy(VC, p.vcolors.data(), p.vcolors.size() * sizeof(rgb_t));

	#pragma omp parallel for
	for(index_t i = 0; i < p.trigs.size(); ++i)
		VT[i] = p.trigs[i].x();
}

void che_obj::write_file(const che * mesh, const std::string & file, const bool & color, const bool & pointcloud)
{
	FILE * fp = fopen((file + ".obj").c_str(), "w");
	assert(fp);

	fprintf(fp, "# OBJ generated by gproshan\n");
	fprintf(fp, "# vertices %lu\n", mesh->n_vertices);
	fprintf(fp, "# trigs %lu\n", mesh->n_faces);

	for(index_t i = 0; i < mesh->n_vertices; ++i)
	{
		const vertex & v = mesh->point(i);
		fprintf(fp, "v %f %f %f", (float) v.x(), (float) v.y(), (float) v.z());
		if(color)
		{
			const vertex & c = mesh->color(i);
			fprintf(fp, " %f %f %f", (float) c.x(), (float) c.y(), (float) c.z());
		}
		fprintf(fp, "\n");
	}

	if(!pointcloud)
	{
		for(index_t he = 0; he < mesh->n_half_edges; )
		{
			fprintf(fp, "f");
			for(index_t i = 0; i < che::mtrig; ++i)
				fprintf(fp, " %u", mesh->halfedge(he++) + 1);
			fprintf(fp, "\n");
		}
	}

	fclose(fp);
}

che_obj::parser::parser(const std::string & file)
{
	FILE * fp = fopen(file.c_str(), "r");
	assert(fp);

	std::vector<uvec3> P;
	uvec3 vtn;
	bool neg = false;
	index_t n = 0;
	float x, y, z, r, g, b;
	char line[512], str[512];

	while(fgets(line, sizeof(line), fp))
	{
		switch(line[0])
		{
			case 'f':
			{
				P.clear(); vtn = {}; n = 0; neg = false;
				for(index_t i = 2; line[i]; ++i)
				{
					switch(line[i])
					{
						case '/':
							if(neg) vtn[n] = 0 - vtn[n];
							neg = false;
							++n;
							break;
						case '\n':
						case ' ':
							if(neg) vtn[n] = 0 - vtn[n];
							if(vtn[0]) P.push_back(vtn);
							vtn = {}; n = 0;
							neg = false;
							break;
						case '-':
							neg = true; break;
						default:
							if('0' <= line[i] && line[i] <= '9')
								vtn[n] = 10 * vtn[n] + line[i] - '0';
					}
				}

				for(uvec3 & f: P)
				for(int i = 0; i < 3; ++i)
				{
					if(!f[i])
					{
						f[i] = NIL;
						continue;
					}
					switch(i)
					{
						case 0: f[i] += f[i] > vertices.size()		? vertices.size()	: -1;	break;
						case 1: f[i] += f[i] > vtexcoords.size()	? vtexcoords.size()	: -1;	break;
						case 2: f[i] += f[i] > vnormals.size()		? vnormals.size()	: -1;	break;
					}
				}

				for(index_t i = 2; i < P.size(); ++i)
				{
					trigs.push_back(P[0]);
					trigs.push_back(P[i - 1]);
					trigs.push_back(P[i]);
				}

				break;
			}
			case 'v':
			{
				n = sscanf(line, "%*s %f %f %f %f %f %f", &x, &y, &z, &r, &g, &b);
				switch(line[1])
				{
					case ' ':
						vertices.push_back({x, y, z});
						n == 6 ? vcolors.emplace_back(r, g, b) : vcolors.emplace_back();
						break;
					case 'n':
						vnormals.push_back({x, y, z});
						break;
					case 't':
						vtexcoords.push_back({x, y});
						break;
				}
				break;
			}
			case 'u':	// usemtl
			{
				sscanf(line, "%*s %s", str);
				objects.emplace_back(str, trigs.size());
				break;
			}
			case 'm':	// mtllib
			{
				sscanf(line, "%*s %s", str);
				mtllibs.insert(str);
				break;
			}
		}
	}

	fclose(fp);

	objects.emplace_back("", trigs.size());

	gproshan_error_var(vertices.size());
	gproshan_error_var(vnormals.size());
	gproshan_error_var(vtexcoords.size());
	gproshan_error_var(vcolors.size());
	gproshan_error_var(trigs.size());
	gproshan_error_var(objects.size());
}


} // namespace gproshan

